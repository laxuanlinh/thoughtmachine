# Vault Core fundamentals

## Legacy banking platforms
- Old system for just some products
- More functionalities, reporting, ...
- Duplication, disjoined data, no real-time reporting
## Vault Core
- Vault Core API: interact with external applications, it does authentication, smart contracts, simulation, role management...
- Postings: keeps track of all movement of funds within Vault Core, credit, debit...
- Streaming: real-time streaming with Kafka, events like accounting, posting events, customer change ...
- Vault Core has 3 main functionalities:
    - Implement bank's portfolio: saving, credit accounts, mortgages ...
    - Maintain customer accounts
    - Generate and record postings in and out of the accounts
- Vault Core Ledger records the postings once they're accepted into Vault Core, this is a common platform that any banks can use
- Smart Contracts are code modules, implemented in Product Engine, allows to reuse code, customize ...

## Vault Core Product Engine
- Smart contracts allow any products to be implemented
- Can replicate existing products for migration
- Can use SDK to build or use existing products in product library (generic product, saving account...)
- Built-in testing framework to unit test, mock and simulate.

## Vault Core Ledger
- Rich: Capture multiple partitions of an account, different denomincations, assets, monitor and maximize/minimize interest
- Expressive: Can slice and dice balances into any structure, no limit transparancy, personalized reporting
- Real-time: Stream events, monitor behaviors and maximize/minimize interest
- Can manage any line of funds, currencies, coins or reward points

## Developing Banking Products
- Written in subset of Python, use common functionalities via Contracts API
- Can look into the code the see how it caculcate interest rate ..etc...
- Can be configured to be executed automatically via life cycle hooks when a customer does something
- Can pass parameters

## Smart Contract Hooks
- Contract events: when execute or upgrade a contract on an account for example when opening and closing accounts
    - Post-activate
    - Upgrade
    - Close code.
- Scheduled events: configurable via Smart Contract
    - Execution schedules: returns set of events, schedules that they run on
    - Scheduled code: returns when a scheduled event is executed, for example recurring payments
- Posting events: when an event is posted into the Ledger
    - Pre-posting: before the posting, determines whether the event is accepted into the Ledger
    - Post-posting: runs after an event is posted successfully
    - Pre-parameter: runs everytime there is a request to update the instance level parameters
    - Post-parameter change: run when parameters are updated.
- Parameter events

## Vault Core Integration
- Responsibilities:
    - **Manufactering products** with Smart Contracts, writing python code and deploy to Vault Core
    - **Managing accounts**, every time a customer opens a new account, a Smart Contract is executed to determine the parameters and operations of this account
    - **Postings**: either via Postings API or the Smart Contracts can generate events themselves. The Ledger records these events
    - **Managing customers**: *Vault Core cannot handle PII* so these information has to be stored some where else. The holding of a customer in Vault Core is linked to this information via a *unique ID*.

- Other functionalities within a bank:
    - **KYC and AML**: verify identities and avoid risky customers
    - **Cards and payments**: make and receive payments from other banks
    - **Fraud monitoring**
    - **Credit scoring and credit risks**: who to lend to and how much
    - **Data reporting and analysis**

# Vault Core Architecture
## Vault Core APIs
- There are 4 entities that Vault Core is responsible for:
    - Product: these are smart contract written in Python and can be deployed to Vault. Vault will run these contracts and other microservices will carry out the relevants tasks dictated by the Python code.
    - Account: there are 2 types of account: Internal and Customer account. The Customer account is an instance of a smart contract so when a customer opens an account, a version of a smart contract is run. Each customer account has balances.
    - Postings: these are events generated and kept track by the Vault Core when there are movements of funds. There are 2 sources of postings: Postings API and Contract API. Postings API will be used in the lifecycle of funds transfer. Contract API is used when needed, for example when the interest or fee accumulates. The ledger persists any events generated by both sources.
    - Customer: unique ID to link with external Customer Relationship Management (CRM)

## Thought Machine Application Architecture
- There are 2 layers of TM application:
    - Configuration Layer: customizable, TM provides tools and training, specific for each client
    - Platform Layer: common for all clients
- The Configuration Layer is totally customizable for the end user. It comprises of Chart of Accounts and Smart Contracts.
- The client can build their own applications based on their needs, using the tooling and training from TM.
- The Platform Layer is built by TM and the client can only use the APIs to upload the content of Configuration Layer like Smart Contracts so that the Vault can run them.
- Vault Core can be run with only the changes from Configuration Layer (Smart Contracts)
- Each smart contract can be scheduled to run certain functions instead of relying on a global schedule.
- Instead of having multiple APIs/components for types of payments, Vault Core has only 1 postings/payments API that any payments can hook on the same way.
- Payment devices like credit cards are not depenedent on the account logic so 1 device and be hooked onto multiple accounts. For example a payment card can be associated with a debit account and a credit account account and the customer can switch between them.
- Cloud native, highly available, can run in multiple regions, can use CSP's backup solution instead of manual backup.

## Creative Migration Strategies
- Vault Core offers solution to migrate existing data into the new system with 6 key properties
    - Data is migrated and maintained and **account level**, via APIs that support real-time sync
    - Dependency management, can config dependencies so that we can input data in any order but it's only loaded until all dependencies are met.
    - Load process is fully automated from API request to streamed events
    - Real-time event streaming which can immediately provide data to downstream systems.
    - When testing, can fast forward in time to test how the legacy products behaves against the known baseline.
    - Strategies like Production parallel run and other migration designs based on the event streaming architecture

## APIs
- Internally, Vault Core has a microservice architecture including these smaller services:
    - **Products and Accounts**: manages smart contracts, customer accounts (also smart contracts), chart of accounts and double-entry bookkeeping (debit and credit recording)
    - **Flags and Parameters**: manages all parameters configured for the smart contracts
    - **Postings and Balances**: keep tracking of fund movements, the ledger prioritizes from high to low topics. Point in time processor handles postings from scheduled events. Balances are side effects of postings.
    - **Calendar and schedule**: manages the scheduled events defined by smart contracts.

- Core API: 
    - Account management: view accounts, open/close accounts, change status, update instance parameters of an account
    - Product management: upload or change version of smart contracts
    - Restriction: restrict accounts in case of lost card or malicious activities, stop accounts from being closed or updated.
    - Smart contract simulation
    - Internal accounts: chart of accounts
    - Roles management: manage employee roles and service tokens 
    - Flags: add flags to accounts or customer entities, allows to impact the accounts for custom reasons.
- Postings API:
    - Authorization check on accounts
    - Settlement of funds
    - Release of funds
    - Posting debits and credits to Vault.
- Streaming API:
    - Account change events
    - Accounting events
    - Posting balances events
    - Customer entity status changes
    - Payment device events
    - Smart contract activation, version change
    - Configuration change.
- Data Loader API: load data from legacy core to Vault Core. Data is loaded asynchronously via Kafka. All data is loaded throught 1 API, except for postings. It's basically an ETL pipeline. By the time the data is loaded to Vault Core, it's already extracted and transformed into an appropriate format.
- The Postings APIs are integrated into Vault Payment processor and Vault Card processor. This is done out side of Vault Core so it's not responsible. All payment schemes and cards are integrated in the same manner.
- Outside the payment processor and card processor, we also have our own payment/card scheme and fraud engine
- The streaming API allows stream events to other systems like Data Warehouse. It's recommended to consume all events to get a complete picture.

## Middle Tier system
- Outside of Vault Core, can use a middle tier system to integrate with the wider banking systems like notification, authentication 

## Operation Dashboard
- Allows back office users to carry out tasks using GUI, integrated with Core API.
- Has role based access control
- Each action has a permission
- Sets of permissions are grouped in to roles, each employee is assigned role.
- It has tools to service products and accounts held in Platform Layer.
- It can upload new or updated version of smart contracts.

## Configuration data in Vault
- There are 3 ways to deploy smart contracts to Vault Core
    - Operation dashboard
    - Core API
    - Configuraiton layer utilities
- Operation dashboard and Core API are mostly used to upload POC smart contracts
- Most banks want to deploy new contracts via CICD pipelines using the Configuration layer utilities.
- There are 4 types of data in Vault Core:
    - **Financial data**: ledger, accounts data store, balances data store, this the the source of truth
    - **Configuration data**: smart contracts, Configuration Layer Utilities is used to deploy smart contracts
    - **Supplementary data**: data used by Vault Apps (Configuration layer???)
    - **Service data**: data used to monitor the Vault instances, including logs and tracing.
## Entity model
- There are 3 types of entities in Vault Core
    - Postings ledger: contains all fund movements
    - Balance data store: balances are the aggregation of postings
    - Account data store: each account is an object associated with resources that make up a bank account, including stakeholders, balances. Each account is an instance of a smart contract.
- Postings are appended to the ledger and cannot be changed, the list of postings is the source of truth and is used to calculate the balances
- There are 2 types of accounts: Internal and Customer account.
- Internal accounts are not defined by Smart contracts and is used to allocate and track funds for the financial institution.
- Each customer account can be divided into multiple addresses, each address has its balance. The balance of each address is calculated by the postings made against that address.
- The structure of addresses is dictated by the smart contract but can also be dynamically creatd when a posting is accepted (maybe a posting that doesn't belong to any existing addresses???)
- The net balance of an address is calculated according to the type of the account: asset or liability.

# Key Resources and Data Model
## Vault Architecture Principles
- All objects in Vault core can be created, read, updated and deleted via Core API
- Objects are only soft deleted
- Objects are only appending updated, meaning a new version of an object is created.

## Vault's data dictionary
- Vault documentation hub provides the documents, tutorial for all the changes of Vault Core.
- There are also Migration Data Dictionary, Migration Tech Deck and Migration Client Case Studies.
- Data Dictionary provides describes the validation requirements for all API fields when a request is sent to Data Loader API or Postings Migration API. It describes how Vault treat migrated resources.

## Key Account Resources
- Beside Core, Postings and Streaming API, Vault Core also has the following APIs:
    - Audit API: audit all incoming API requests
    - Data Loader API: migrate legacy systems' data.
    - Access Control API: manage roles of employees.

## Smart Contract entities
- Smart contracts are the entities that digitally enforce the agreements between the bank and customers, therefore they define the finacial behaviors of an account and how the balances are calculated.
- All products are smart contracts and they are the finacial behaviors of an account.
- Each product has some metadata and a product version number which points to the version.
- This product version point the Customer Account to the version of the Smart Contract it executes
- Each product has multiple versions, each version can be linked to multiple customer accounts
- Each product version contains the code of Smart Contract such as Metadata, parameters, events, data fetchers and hooks
- All live customer accounts point to a product version in Vault Core.
- A product can be upgraded to the latest version of the smart contract.

## Account Data Model
- Thought Machine doesn't have CRM and only provides an external ID field to connect with external CRM systems.
- Vault Core provides some fields like first name and last name if necessary.
- A customer can be linked to multiple accounts, an account can also have multiple customers linked via the field stakeholders.
- An account contains the monetary data and metadata includes:
    - Opening date
    - Stakeholders
    - Instance parameters
    - Linked payment devices
    - Account details, follows key-value structure to capture custom data.
- Update accounts via Account Update API
- Not all updates to accounts can be done synchronously, because some of them require smart contract code to be run. These updates include
    - Change instance parameters because it requires *pre_parameter_change_code* to be run
    - Change product version because it requires *upgrade_code* to be run
- All customer accounts have at least 1 balance.
- Balances are calculated using 4 dimensions
    - **Asset type** (Commercial bank money or another asset type)
    - **Denomination** (currencies like USD, SGD)
    - **Address**, address maybe where to track interest or to store sub-pots for saving or where the bank can track fees 
    - **Phase**, there are 3 phases *Incomding*, *Outgoing* and *Committed*
- Balances have 3 attributes:
    - Total debit
    - Total credit
    - Net: depending on the type (T-side) of the account Asset or Liability

## Payment devices
- Payment devices provides external account ID
- Customers can select account to charge using a single card, customer can route the payment to multiple accounts and can 1 account can have unlimited number of supplementary cards
- A payment device can be email, card, account number, phone number, physical payment device ...
- A payment device can link to 1 or multiple accounts using unique Payment Device Links
- Each link has a token that can be used to identify the links and make postings to.
- Multiple devices linking to the same account can share 1 token with each device having status Active or Inactive.
- Or each link can have a unique token created by external systems to enable

## Posting Instruction batches
- Posting Instruction batches represent the movements of funds between accounts.
- A single Posting Instrcution batch is made up of many Posting instruction.
- A Posting instruction always contains at least 2 postings, credit and debit.
- Higher level concepts like transactions and payments are just made up of postings, for example transactions are made up of 2 or more postings
- If we need to reverse or correct a posting, we have to make new backdated postings

## Internal accounts
- Internal accounts are internal accounts of the bank, it shows how much money the bank owns
- It's used on the Vault ledger to meet accounting requirements
- Internal accounts don't use smart contracts liks Customer accounts with any metadata, it only uses a blank Smart contract to maximize performance.
- Internal accounts are not associated with a customer entity, they're owned by the bank itself

## Audit entities
- Audit module tracks requests and effects of those requests on the resources in Vault Core.
- The audit events can be accessed via REST API or Kafka (Audit Streaming API)
- Audit logs record all incoming requests and responses
- Action logs record the action that these requests perform on the entities in Vault Core such as accounts or payments and the information changed by these actions.
- Both log types are immutable and can be acccessed via REST API or Audit Streaming API, they can also be viewed from Operation Dashboard.
- Audit logs are kept for some time while Action logs are kept indefinitely.
- While Audit logs remove sensitive information like tokens, it won't remove things like balances, postings or account data.
- We need to use policies to limit the number of users who can view the Audit logs.

# Financial Principles
- Unified Postings API
- Consistency of Financial state
- Ability to model complex processes
## Financial records
- A financial record in Vault Core consists of of 3 components:
    - Postings
    - Balances
    - Accounts
- A posting is a debit or credit, postings are appended to the Ledger which is the source of truth
- A balance is the sum of all postings and is stored against an address. Net balance is computed according to address type: asset or liability
- A customer account is partitioned in to addresses, each address has a balance. The structure of an account is dictated by the smart contract but addresses can also be dynamically spawned when it's targeted by postings that are accepted against the account.

## Unified Postings API
- Postings are communicated via Postings API which is Kafka based and request-reply model
- Vault Core exposes only 1 API for Postings which can handle all complex posting data, within 1 account, between 2 accounts or with external accounts
- External integration will also use Postings API such as Card Payment or Inter-bank transfer
- Vault Services will also use Postings API for on-Vault Posting (???) such as accrual of interest or accrual of typical fees on an account.

## Consistency of Financial state
- All postings are immutable 
- Postings are the lowest level of Customer facing transactions. Each payment or trasactions can have more than 1 postings
- The Postings API ensures that each request has a balanced set of debit and credit (what does this mean???) to follow the double entry bookkeeping model.

## Ability to model complex processes
- There are many posting types such as Authorization, Settlements...
- These types can be used to model complex processes such as Card transactions, authorization of funds, transfer...
- The benefit of using posting types is that we can add logic such as during Card transactions, authorization has to happen before settlement.

## Posting objects
- There are 3 types of objects when dealing with Postings API
    - Posting: the smallest object, represents debit or credit, it also has asset type (Commercial bank, reward point ...), denomination (currency), amount, account ID/address, phase
    - Posting instruction: the building block of any transaction, it contains 1 or more Postings, it also contains type such as Inbound/Outbound authorization, Release/Settlement, Adjustment, Transfer and Custom Instructions
    - Posting instruction batch: contains 1 or more Posting instructions, if 1 of these instructions fails, the whole batch will fail. The batch captures the result of the instruction being posted, either accepted or rejected

## Posting types
- There are 9 posting types, can be divided further into 2 categories Standalone (s) or Chainable (c)

### Outbound and Inbound authorization (c)
- Put funds on hold and exepected to be settled or alternatively released later
- Vault usually moves funds from sender balance pending phase to recepient's balance pending phase.
- Depending on the type Inbound/Outbound, the phase could be Pending Incoming or Pending Outgoing.
- For example when we buy fuel at a gas station, upon reading the card with authorized amount we can spend, Vault moves the funds with posting type Pending Outgoing from our account to the station's account. Once we have pumped enought fuel, a Settlement posting type should follow to cover the actual cost of the fuel.

### Authorisation Adjustment (c)
- Used to increase the amount of previous pending authorized funds, this will change the total amount of a transaction
- For example if a customer decides to stay in a hotel a bit longer, the hotel can send an Authorisation Adjustment posting to increase the amount of the transaction. At the end of the customer's stay, the total amount is the authorized amount + the Authorisation Adjustment amount.
- It can also reverse the hold status of a Inbound/Outbound fund that was previously authorized.

### Settlement (c)
- Settlement posting is to move the pending funds to the committed state.
- A Settlement posting has to be linked to a Inbound/Outbound authorization posting so that it can move the fund of this posting to Committed.
- We can settle more or less the amount that has been authorized before.
- If we need to settle less, Vault will do a Release posting the remaining balance.
- For example when a customer makes a transaction online, the scheme first submits the authorized account with a Pending Outgoing posting. Then a scheme will submit a clearing request to debit the money from the customer's account. 

### Release
- Release postings reduce the amount of pending fund to zero, meaning it releases the transaction.
- A Release posting has to be linked to a Inbound/Outbound authorization posting.
- No posting can follow a Release posting because it closes the transaction.

### Transfer Posting
- This posting type debits a fund from an account and credits it to another account, effectively create 2 postings
- Transfer postings transfer the funds from committed phase of sender's balance to committed phase of recepient's balance.
- Transfer type is used to facilitate the transfer of funds usually between accounts of the same customer or bank.

### Inbound/Outbound Hard Settlement
- Hard settlment allows to transfer money from committed phase of 1 account balance to another account balance's committed phase without any prior authorization.
- This posting type doesn't expect any further modification of the transaction.
- It can also be used to debit or credit funds to an internal account, follows the double entry model
- It allows to specify whether it's an inbound to the customer's account or an outbound from the customer's account - usually to an internal account.
- Hard settlement can be used in Stand-in payment, when a Payment Gateway cannot connect to the Payment hub despite the authorizatoin and settle postings are accepted, then the Gateway can operate in Stand-in or Offline mode, meaning it accepts the payment and later when the Hub comes back online, it can make a Hard Settlement posting
- Another usecase is to reverse a payment or to refund.

### Custom instruction
- Custom instruction type can move funds from any account, any address, any phase to other accounts. It should be able to satisfy the remaining usecases that the other types cannot.
- To create Custom instruction, we can use Postings API or the Smart Contract itself.
- An example of this is to calculate daily and monthly accrued interest. Another example is Annual fee charged to a credit card
- A popular options for saving is to allow creation of many Saving pots within a Saving account, each pot has its own interest. This will create many addresses within the account and requires Custom instructions to move money between them.

## Postings lifecycle
- A customer initiates a payment via their bank app
- The Payment hub receives the message and call the Postings API to authorize the payment
- The Payment hub then exchanges messages with the Payment scheme, if all messages are sucessful then it call the Posting API to settle the payment.

## Balances
- There are 2 types of balance: Balance resource and Ledger balance resource.
- Balance resource is used by smart contract to process payments or calculate interest.
- Ledger balance resource is used to show the state of customer account's balance, internal account's balance and provide a snapshot of the Ledger. It's also used at the end of accounting, reconciliation and reporting cycle
- Different products require different ways to calculate the balances and how the accounts are partitioned.
- The architecture of Vault Core also allows the accounts to be dynamically partitioned into smaller addresses

## Balance details
- Balances are calculated across 4 dimensions, this allows any account structured to be represented:
    - Asset type: commercial bank or reward point or something else
    - Denominaton: any currencies in the world or even fake currencies like Hilton Hotel Point or Avios Air Miles
    - Address: each address is a partition of the total balance. Each has its own balance and interest. For example it could be used to accrue interest or to save money for Car, Vacation ...
    - Phase: there are 3 phases that funds are stored in an address Pending Outgoing, Pending Incoming and Committed, depending on where they are during payment lifecycle.
- A balance has 3 attributes:
    - Total Debit
    - Total Credit
    - Net.
- Net are calculated based on the T-side (whether it's Asset or Liability), *T-side* is determined within *Smart Contract*
- If Asset then Net = Debit - Credit
- If Liability then Net = Credit - Debit
- If we select the balance sheet, we can see there are a lot of accounts, Customer and Internal, they all follow the same account model.
- Customer account can be personal loan, mortgage or saving.
- For example: 
    - Account A has 2 asset types: Commercial Bank Money and Reward Points
    - Inside the Commercial Bank Money, we see multiple denominations USD, SGD, GBP
    - Each denomination consists of mulitple addresses: Available balance, Fee owned, Intereste charged...
    - Each address has 3 phases: Incoming Penidng , Outgoing pending and Committed
    - The denomination USD, address Avaialble Balance, there are 5000 USD in the Committed phase, this means the customer has 5000USD to spend

## Double Entry Bookkeeping
- Vault uses double entry bookkeeping system, meaning each entry of credit has to be followed by 1 or more entries of debits with the equal total amount in either the Customer account or Internal account and vice-versa.
- Example: A customer puts down 100 USD to reserve at a hotel
- Vault posts a Authorization posting of 100 USD from Pending Outgoing phase of the customer's balance to the Internal account.
- The customer then wants to extend the stay so the Vault posts Authorization Adjust posting of 50 USD from the Pending Outgoing phase to the Internal Account.
- Finally the customer checks out at the hotel and uses the credit card to settle the money. Vault use Settlement posting type for this.

## Value Dating and Back Dating
- Normally, postings are generated and applied immediately to calculate the balances. Each time a posting is generated, balances are recalculated thus creating a series of balances and allows to take a snapshot of historical balanaces at a point of time.
- However there are times when we need to go back in time and adjust the postings.
- To do this, we need timestamp, there are 3 types of timestamp:
    - *insertion_timestamp*: is when Vault processes a posting and persists in the database. Vault always sets this value, for reporting purposes
    - *value_timestamp*: is when the fund should have moved between accounts. It can be set by Vault or client, depending on where it comes from. The *value_timestamp* is <= *insertion_timestamp*
    - *booking_timestamp*: is when the posting is booked. By default, Vault sets this value based on the *value_timestamp* given that the booking period is still open, if not then it sets the *booking_timestamp* to *insertion_timestamp*. It's possible to override the default value by setting this value explicitly, the value has to be between *value_timestamp* and *insertion_timestamp*
- To set back date posting, create a posting with value_timestamp in the past. Vault will append this back date posting to the ledger and take this posting into account when calculating balances.
- Recalculation of interest, fees that has resulted from external API calls or scheduled events will have to handled separately.
- It's recommended to use the Simulation API to calculate what the balance should be, then make the back date postings to adjust.
- The event of back date posting is streamed out via Streaming API.
- Example:
    - On Day 1 (D1), at 22:00, Vault receives a credit of $100, Vault is the Source of Truth so it sets the timestmaps as follow:
        - insertion_timestamp: 22:00
        - value_timestamp: 22:00 (matches with insertion_timestamp)
        - booking_timestamp: 22:00 (matches with value_timestamp)
        - booking period: D1
    - On Day 2 (D2), at 00:10, Vault receives a debit of $10 at 00:09, Vault is now the System of record:
        - insertion_timestamp: 00:10
        - value_timestmap: 00:09 (the actual timestamp when the posting is made)
        - booking_timstamp: 00:09 (matches the value_timestamp)
        - booking period: D2
    - D2, 00:15, debit $20 at 23:55 D1. This is a late posting with booking period of D1, the client manually sets the booking_timestamp to 23:55 D1, Vault still accepts it because D1 has not cut off yet.
        - insertion_timestmap: 00:15
        - value_timestamp: 23:55 D1
        - booking_timestamp: 23:55 D1
        - booking period: D1
    - D2: 01:10, debit $10 at 23:50 D1. This is too late and there is no manual booking_timestamp, the D1 period has already closed, Vault sets the booking period to insertion_timestamp D2
        - insertion_timestamp: 01:10
        - value_timestamp: 23:50 D1
        - booking_timestamp: 01:10 D2 (matches the insertion_timestamp because booking period is closed, no manual override)
        - booking period: D2

# Product and Integration libraries
## Product library
- Designed to provide configurable, feature rich smart contract using best practices
- Testing libraries include unit test, integration testing and simulation
- Clients have access to pre-built smart contracts ready to be deployed, can be easily configured to meet differnet
- Smart Contract Framework provides the ability to cater the whole suite of lending solutions for all financial instutitions, banks ...
- Interest rate can be configured to be accrual, fixed, variable rate, positive or negative rates
- Support multi currency accounts, overdraft protection...
- To access product library, go to Enablement portal.

## Integration library
- Degisned to accelarate go live process
- Currently the Integration library has not been updated to use the latest features of Vault Core 5.
- Includes integration builds by Thought Machine and by other vendors.
- Similar to Product library, all builds are easy to configured, built with best practices, include testing libraries to unit test and end to end test. 
- It's free if clients have signed Master Service Aggreement.
- Use the Integration library to integrate with trusted vendors like Transfer Wise, Oracle, Salesforce...
- The ecosystem of integration builds are divided into 6 segments: Moving money, Data and analytics, Customer knowledge, Customer channels, Infrastructure tooling and 
- All platform functionalities are exposed via a standard set of APIs.
- For example: For Google BigQuery, Thought Machine has built an integration library that allows clients to use this servie to digest big data from different sources and take advantage of its machine learning, BI tools and its add-on
- Another example: Moneythor is a vendor that can offer personalized money management, providing recommendations based on customers' purchases and behaviors. If a customer buy from KFC or McDonald, their merchant codes are captured from the postings and recommendations appear on the mobile app. It can also recommends to use overdraft if eligible or alert the customer that the upcoming bill is not affortable.
- To do this, separate Kafka topics are consumed by integration service for accounts, postings and balances events, these events are transformed into messages and pushed to Moneythor via Kafka again.
- All documentation about all integration is maintained in Enablement portal.

# Core Streaming
## Streaming API overview
- There are 2 types of API: REST API for synchronous and Streaming API for asynchronous.
- Streaming API is based on Kafka
- All Vault components have outbound a streaming API which uses push mechanism to stream their state changes in near real time 
- Each event type like Posting or balance update has a dedicated topic so that external system can subscribe to.

## Challenges of legacy systems
- No real-time, cannot scale to retrieve large amount of data, batch processing results in poor performance and downtime, tight coupling with internal database model and slow to change.
- Vault Streaming API offers near real-time updates, can scale thanks to Kafka that can stream events to many consumers, no downtime because Kafka streams events in real time to external services and no competition between reporting/analytics and transactional processing, decouples internal database model from events and allows faster change adaptation.

## Streaming API benefits
- Near real-time
- Guaranteed at least once delivery
- Access to all underlying state changes
- Can scale
- Can stream to as many consumers as needed without affecting the core
- Granular access to extensible data model.
- Advantages can be categoried into 4 areas:
    - Operational efficiency: not having batch processing and no downtime and can scale to retrieve large data
    - Response to change: banks can respond to changes in real-time and take action based on events
    - Advanced anatylics: banks can build analytical tools and AI based on real time events
    - Ease of integration: changes made to underlying products like smart contracts don't affect the downstream services that consume events.
## Data types
- Facts: describing the creation of resources like creation of new accounts, postings and balance updates.
- Resource mutation: describing the changes of resources like product version updates, account updates, device updates
## Integration and use cases
### Improve customer loyalty through real-time tailored insights
- Posting events are consumed in real time and fed into models to predict cash flow shortfalls and reaching spending limits to alert
- Postings and balance events are used to predict spending patterns and fed into gamification engine to give reward point or cashback in real time
- Posting data can be enriched with classification, geo-tagging and merchant and embedded into customer facing application to increase transparency 
- Enable if-else rules in real-time to enable business intelligence, for example if balance exceed this threshold then credit $100 to saving account
### Reduction of financial risks through continuous liquidity monitoring
- Vault can provide banks with continuous liquidity monitoring by looking into the posting and balance events streamed in real-time.
- Posting events are streamed in real-time to downstream services that can run risk analysis instead of having dated information.
- Vault can be come the only source of truth that other downstream services can rely on to make decicision
- Vault is also online 24/7 and it supports creation of liquidity monitoring processes that can detect/forecast unexpected spikes and allows banks to hold a smaller buffer for any liquidity shortfalls.
### Increase revenue using contextual, personalized products
- Near real-time data allows bank to modify smart contract parameters dynamically according to customers behaviors.
- Match product offering against customer risk profile and provide transparency
### Enable real-time general ledger and reconciliation integration
- Near real-time posting data allows banks to immediately access the state of liquidity, profit and loss.
- Banks can achieve real-time general ledger and reconciliation operations
- Depending on the reconciliation strategy, balances can be retrieved via Core API daily or intra-daily.

# Documentation hub
## Overview
- One stop shop for all documentation
- 4 main areas: Vault Core, Vault Payment, Vault Core SaaS, Vault Core Product library
- Available with every instance and tagged that Vault instance version

# Smart Contract
## What is a smart contract?
- It's python code that is run by Vault to operate financial products like saving accounts, lending products or current account
- Smart Contract has the following characteristics:
    - They are configuration of financial products and part of the Configuration Layer, it's how the Vault can bring these products to life.
    - Transparent beause it encapsulates all logic and parameters of financial products within its code
    - Autonomous because it's executed automatically by the Vault during the acccount lifecycle or at scheduled times
    - Parameterizable as it can takes in parameters for each type of product
    - Flexible because code and parameters can be updated and deployed easily using Core API
### Key Vault Resource - Account
- A customer account can be linked to 1 or more customers and is governed by the logic within Smart Contract associated with that account.
- A customer account holds the balances and other metadata such as:
    - Opening date
    - Stakeholders: list of the linked customers
    - Instance and account level parameters
    - Linked payment devices
    - Account details: key/value to store unstructured data.
### Key Value Resource - Posting
- Posting instruction batches describe the movements of funds
- Each Posting instruction batch consists of multiple Posting instruction
- Each Posting instruction has at least 2 posting Debit (money in) and Credit (money out)
- Postings are immutable and appended to the Ledger, so to update a posting, we have to add backdated postings.

### Key Value Resource - Balance
- Balances are calculated across 4 dimensions:
    - Asset type (Commercial bank money or reward point)
    - Denomination (USD, SGD)
    - Address
    - Phase
- A balance has 3 attributes:
    - Total debit postings
    - Total credit postings
    - Net
- A lending product is considered asset because the customer owes the bank money while a deposit account is considered liability because the bank owes the customer money.

- A smart contract that is associated with an account dictates the behavior of that account such as:
    - Accept or reject transfer
    - Settling account opening actions
    - Settling account closing actions
    - Creating scheduled actions

## Business advantages of Smart Contract
- In the 1st generation of banking system, each product has its own core system like Account, Lending, Deposit.
- This approach makes it difficult to have the big picture of the financial state of the bank.
- Customer data has to be pulled from different sources and conformed into 1 standard 
- In the 2nd and 3rd generaton, the banking systems are bigger and able to handle multiple products. Entities such as Customer can be represented once and are associated with multiple products.
- Financial products are also parameterized so banks can customize their products.
- The problem with the 2nd and 3rd gen is that the features are vendor locked and banks cannot add their own features. They have to go back to vendors to request for changes and slow to test and deploy.
- Smart Contract is more flexible because now banks can implement their own products in whatever logic they want and can test and deploy on their own instead of relying on a fixed set of products and parameters.

## Smart Contract Hooks
- Hooks are interface that Vault can communicate with smart contracts
- Hooks are financial behavior of smart contracts and they are called by Vault at different times throughout the lifecycle of smart contract.
- When an account is created, the activation_hook is called immediately. This hook could disburse a loan amount to a linked CASA account if the customer is opening a loan product or disburse a small signup bonus to a wallet account during a promotion period.
- Also during account opening, the execution schedules job is run to set the schedules of other jobs that are set by the writter of the Smart Contract.
- Before some money is transfered into an account, the hook pre_posting_hook is run to verify that the fund can be transfered.
- After the posting has been added to the Ledger, the Vault will call post_posting_hook, this hook can rebalance the balance or auto save the spending...
- Depending on the timing that has been set in the activation_hook, the scheduled_event_hook will then execute the logic like profit accrual
- To update the parameters of a contract, we can use Core API and this will involves 2 other hooks pre_parameter_change_hook and post_parameter_change_hook. Actions such as recalculating profit can be done in post_parameter_change_hook.
- If we want to update the version of the contract then conversion_hook will run.
- When we close the account via Core API, the deactivation_hook will run, this hook will typically include the logic to for closing accounts like zeroing out the balances.

## Hook decorators
- To specify what data to be fetched in @fetch_account_data, we need to use the data fetcher in smart contract.
```python
data_fetchers = [
    ParametersIntervalFetcher(
        fetcher_id = 'param_if_1',
        filter=ParametersFilter(parameter_ids=['interest_rate']),
        start=RelativeDateTime(shift=Shift(months=-1), Origin=DefinedDateTime.EFFECTIVE_DATETIME),
        end=DefinedDateTime.EFFECTIVE_DATETIME
    ),
    ParametersObservationFetcher(
        fetcher_id = 'param_if_2',
        filter=ParametersFilter(parameter_ids=['interest_rate']),
        at=DefinedDateTime.EFFECTIVE_DATETIME
    ),
    BalancesIntervalFetcher(
        fetcher_id='bif_1',
        filter=BalancesFilter(addresses=['SAVING', 'INTEREST']),
        start=RelativeDateTime(shift=Shift(month=-2), Origin=DefinedDateTime.EFFECTIVE_DATETIME),
        end=DefinedDateTime.EFFECTIVE_DATETIME
    ),
    PostingsObservationFetcher(
        fetcher_id='pif_1',
        at=RelativeDateTime(shift=Shift(month=-1, day=1), Origin=DefinedDateTime.EFFECTIVE_DATETIME)
    )
]
```
- There are 2 types of fetcher, Observation which fetches data at a point in time and Interval which fetches a time-series data 
- When we write the code for the hooks, we need to specify which data we want to retrieve for those hooks, the Vault will fetch the data before it executes hooks.
- For example to get the parameters, balances and postings, we have to use @fetch_account_data decorator
- We can specify the period that we want to fetch data using conventions like 1_month, 2_year (TBC)
```python
@fetch_account_data(
    parameters=['interest_rate'],
    balances=['1_month'],
    postings=['1_month']
)
```

- Or we can use our own data_fetchers like so:
```python
@fetch_account_data(
    parameters=['param_if_1'],
    balances=['bif_1'],
    postings=['pif_1']
)
```

- For instance or template parameters, we can use @requires with True/False
```python
@requires(
    parameters=True,
    balances=True
)
```

## Helper functions
- In hooks, there are some predefined helper functions such as;
    - get_account_creation_datetime: retrieve account creation date
    - get_flag_timeseries: get flag's value timeseries
    - get_permitted_denominations: get a list of permitted denominations for the account

## Hot Path and Non Hot Path
- When a posting is made to a ledger, hook pre_posting_hook and post_posting_hook execute prior and after it's appended to the ledger.
- The pre_posting_hook -> ledger is considered Hot Path as it can reject the posting while the path from post_posting_hook -> ledger is considered Non Hot Path.
- Each hook can have different performance implication, for pre_posting_hook, the payment providers always expect the payment to be accepted or rejected within a few seconds so it has to be performant, so it's recommended for this hook to have limited data access and only perform a simple balance check.
- All other hooks are Non Hot Path 

## Basic Smart Contract structure
- At the top of a Smart Contract is imports
```python
from contracts_api import ActivationHookArguments, ActivationHookResult, [...], Tside
from typing import Optional
```
- After that is the Metadata section
```python
# current version of smart contract API being used
api='4.0.0'
# the version of this contract
version='3.0.0'
# the display name of the product that will be shown in the API and the Operational Dashboard
display_name='Current Account'
# the summary 
summary='An everyday banking account with optional overdraft facility'
# the tside of the product, for lending it's usually asset, for deposit it's usually liability
tside=Tside.LIABILITY
```
- Next we define all the schduled events that we want to use for this contract and any tags and groups for the events
```python
events=[...]
```
- The Data fetcher section contains all the fetchers that fetch data for this product such as balance obvervation, postings interval or parameters
```python
data_fetchers=[...]
```
- The final section is for the hooks and decorators
```python
@requires(parameters=True)
def activation_hook (vault, hook_arguments: ActivatoinHookArguments) -> Optional[ActivationHookResult]:
    return ActivationHookResult(
        scheduled_event_return_value={
            'event_1': ScheduledEvent(...)
        }
    )
@fetch_account_data(event_type='event_type_1', balances='bof_1')
def scheduled_event_hook (vault, hook_arguments: ScheduledEventHookArguments) -> Optional[ScheduledEventHookResult]:
    return ScheduledEventHookResult(...)
```

## Smart Contract example
- pre_posting_hook checks if the posting contains any disallowed denominations
```python
@fetch_account_data(parameters=['denomination'])
def pre_posting_hook (vault, hook_arguments):
    params_observation = vault.get_parameters_observation(name='param_observation_fetcher_1')
    allowed_denomination = params_observation.get('denomination')
    posting_denomination_used = set(post.denomination for post in hook_arguments.posting_instructions)
    disallowed_denomination_used = posting_denomination_used.difference([allowed_denomination])
    if disallowed_denomination_used:
        return PrePostingHookResult(
            rejection=Rejection(
                message='Cannot make transactions in denominations:'
                f"{','.join(disallowed_denomination_used)}."
                f"Transactions must be in {allowed_denomination} only."
                reason_code=RejectionReason.WRONG_DENOMINATION
            )
        )
```

## Parameters, time series and flags
- Vault supports a range of parameter types:
    - String: general-purpose
    - Decimal: can store currency and interest rate
    - Enumeration: values have to come from a predefined set of values
    - Date Time: date and time
    - Account: can be used to configure target account for posting instructions made by the hooks

- Smart Contracts do not store states, it's stateless.
- To store parameters of an account, we store them as Contract Parameters in Vault and the hooks will retrieve data from the Vault
- There are 4 levels of parameters (class Parameter)
    - Global: shared by all Smart Contracts
    - Template: shared by all instances of a Smart Contract
    - Instance: belongs only to 1 Smart Contact instance
    - Instance (derived): unique to each account, calculate values on the fly, using derived_parameters hook, for example complex calculation such as interest_rate = base_rate + profit_margin_rate + customer_margin
- Smart Contract expected parameters (class ExpectedParameter) have 2 levels:
    - Root level: all smart contracts have access to these parameters
    - Account owned level: unique to each account
    - Currently there is no product level parameters so we can use template level for this purpose
## Shape
- Smart contracts are python objects that follow predefined shapes
- Shapes allow contract writers to validate input, add metadata like UI hinting and permissions
- Shapes support most common use cases like string shape, decimal shape, date shape, account ID shape...
- Writers can write their own shapes
```python
Parameter(
    name='repayment_day',
    level=ParameterLevel.INSTANCE,
    description='Just a descriiption about repayment day',
    display_name='Repayment Day',
    shape=NumberShape(
        min_value=1,
        max_value=28,
        step=1
    ),
    update_permission=ParameterUpdatePermission.USER_EDITABLE,
    default_value=28
)
```

## Constraint
- Similar to Parameter's Shapes, Expected Parameters use Constraints
- Constraints allow writer to validate input and output Expected Parameters, add metadata like value ranges, optionality and whether changing the parameters should trigger the smart contract logic
- Like shapes, constraints support most common use cases like string, number, date time constraint
```python
ExpectedParameter(
    id='repayment_day',
    constraint=DecimalConstraint(
        min_value=1,
        max_value=28
    ),
    trigger_pre_parameter_change_hook=True,
    optional=False
)
```

## Timeseries
- Timeseries is a sequence of data points that occur successively over a period of time which allows us to go back in time and take a snapshot of a resource.
- Vault provides timeseries for the following resources:
    - Balances
    - Parameters
    - Flags
- Some use cases for timeseries are:
    - Retrieving the latest denomination to determine the allowed denomination
    ```python
    denomination = vault.get_parameter_timeseries(
        name='denomination'
    ).latest()
    ```
    - Retrieving a past balance given a timestamp
    ```python
    vault.get_balance_timeseries(fetcher_id='fid').at(
        timestamp=effective_datetime
    )
    ```
    - Retrieving all repayment holiday flag values of the previous month
    ```python
    vault.get_flag_timeseries(
        flag='REPAYMENT_HOLIDAY'
    ).at(timestamp=previous_month)
    ```
    - Retrieving the latest repayment holiday flag value
    ```python
    vault.get_flag_timeseries(
        flag='REPAYMENT_HOLIDAY'
    ).latest()
    ```
## Flag
- Flags are boolean values stored in Vault against Accounts, Payment devices and Balances
- They are used to customize the behavior of individual accounts from another
- Some use cases:
    - Mark an account delinquent when they fail to pay the bills
    - Add repayment holiday flag to an account so that the customer doesn't have to repay their bills on time
    - Flagging with dormant when a customer stop using an account which will freeze it
    - Tier based feature such as better deals for employees

## Testing
- There are 3 levels of testing
    - Unit test: test individual hooks against mocked dependencies
    - Simulation: simulate Vault instance
    - Instance: test functionality against real instances

## Simulation testing
- To simulation test, we use the testing API of the Vault core to send the code, start and end time, events and actions such as postings, activating flags...
- The testing API will return events that happened during the simulation, the balance timeseries and Posting instruction batches that occurred during the simulation
```JSON
"result": {
    "timestamp": ...,
    "derived_params": {
        "Loan Account 1": {
            "values": {
                "next_repayment_date": "2024-09-10",
                "outstanding_payment": "789.12",
                "remaining_principal": "4122.11",
                "remaining_terms": "10"
            }
        }
    },
    "logs": [
        "created account Loan Account 1",
        "set account parameter \"principal\" value to \"5000\""
        "set account parameter \"total_term\" value to \"12\""
        "set account parameter \"upfront_fee\" value to \"0\""
    ]
}
```
- Based on this result, we can see if the smart contract:
    - Scheduled events are executed successfully
    - Expected postings are accepted or rejected
    - Derived parameters are calculated correctly
    
# End of day
## What is End of day
- End of day (EOD) is a set of predefined events that run after banks conclude their operations for the day
- Things we can do at EOD are:
    - Perform interest accrual
    - Post interest
    - Start or mature term account
    - Calculate account EOD posisition or even SOD position
    - Stream customer documents, financial reporting and data for EOD reports
- Events like postings (calculation of interest accrual), events that impact opening account balances ... are crucial and must be executed in a timely manner.
- Other events that do not affect the postings and opening balances should not be included in the EOD operations

## EOD challenges
- Since modern banks operate 24/7, there is a challenge that we cannot stop the bank at a time to calculate positions.
- Since data is constantly changing, it's difficult to calculate positions at EOD
- There are generally 3 common ways to solve this:
    - Extend the EOD past 5PM and keep the down time as short as possible, we don't really solve the problem
    - While the core is closed, use an auxilary system to do payment until the core is back, this is quite complex
    - Never shut down the core, it's always online but difficult to calculate the positions as data is constantly changing

## EOD examples
- A bank accrues interest daily on their saving account at 11:00PM
- It applies interest monthly on the saving account at 11:30PM
- It informs downstream services to run their EOD once both schedules have completed successfully

## Schedule group
- A schedule group will enforce these 3 schedules to run in an ordered manner
- Once the EOD reporting schedule has run successfully, it will send an event with an associated scheduled tag to Kafka to inform other services to run their own EOD
- So the 3 jobs will run as followed:
    - The Accrue interest job runs first at 11PM, it uses contract parameters to decide what the interest should be
    - The Apply interest job runs after that, since we group 3 of them into 3 Schedule group, if the Accrue interest fails to run, the Apply interest job will not run.
    - Once the interest is calculated and applied, the EOD reporting job will run and send out events with an associated scheduled tag to inform downstream services to run their own EOD reporting

## Processing group
- A Processing Group is a Vault resource that groups Accounts and Plans, it can affect all Accounts and Plans within it.
- It's can be used to set status of EOD operations to PAUSED or UNPAUSED.
- If EOD is PAUSED then all the schedules within it will not run.
- This is useful in case the EOD reporting is waiting for a late posting from the upstream services or the upstream services are having issues and need to wait.

# Vault Core SaaS
## Vault Core Platform
- Vault Core is built on a distributed microservices architecture and deployed in containers, using Kubernetes to orchestrate
- Vault Core is cloud-native and banks can choose any vendors
- Thought Machine also offers Thought Machine hosted environment that follows security standards such as ISO 27001 and SOC2
- Clients manage the Configuration layer which is comprised of Smart Contracts and Chain of Accounts, they're also responsible for building their own accounting structure and financial products without relying on Thought Machine.
- Thought Machine provides the tooling, documentation and training
- The Platform Layer is common for all clients and is taken care of by Thought Machine

## SaaS vs bank hosted
