# Vault Core fundamentals

## Legacy banking platforms
- Old system for just some products
- More functionalities, reporting, ...
- Duplication, disjoined data, no real-time reporting
## Vault Core
- Vault Core API: interact with external applications, it does authentication, smart contracts, simulation, role management...
- Postings: keeps track of all movement of funds within Vault Core, credit, debit...
- Streaming: real-time streaming with Kafka, events like accounting, posting events, customer change ...
- Vault Core has 3 main functionalities:
    - Implement bank's portfolio: saving, credit accounts, mortgages ...
    - Maintain customer accounts
    - Generate and record postings in and out of the accounts
- Vault Core Ledger records the postings once they're accepted into Vault Core, this is a common platform that any banks can use
- Smart Contracts are code modules, implemented in Product Engine, allows to reuse code, customize ...

## Vault Core Product Engine
- Smart contracts allow any products to be implemented
- Can replicate existing products for migration
- Can use SDK to build or use existing products in product library (generic product, saving account...)
- Built-in testing framework to unit test, mock and simulate.

## Vault Core Ledger
- Rich: Capture multiple partitions of an account, different denomincations, assets, monitor and maximize/minimize interest
- Expressive: Can slice and dice balances into any structure, no limit transparancy, personalized reporting
- Real-time: Stream events, monitor behaviors and maximize/minimize interest
- Can manage any line of funds, currencies, coins or reward points

## Developing Banking Products
- Written in subset of Python, use common functionalities via Contracts API
- Can look into the code the see how it caculcate interest rate ..etc...
- Can be configured to be executed automatically via life cycle hooks when a customer does something
- Can pass parameters

## Smart Contract Hooks
- Contract events: when execute or upgrade a contract on an account for example when opening and closing accounts
    - Post-activate
    - Upgrade
    - Close code.
- Scheduled events: configurable via Smart Contract
    - Execution schedules: returns set of events, schedules that they run on
    - Scheduled code: returns when a scheduled event is executed, for example recurring payments
- Posting events: when an event is posted into the Ledger
    - Pre-posting: before the posting, determines whether the event is accepted into the Ledger
    - Post-posting: runs after an event is posted successfully
    - Pre-parameter: runs everytime there is a request to update the instance level parameters
    - Post-parameter change: run when parameters are updated.
- Parameter events

## Vault Core Integration
- Responsibilities:
    - **Manufactering products** with Smart Contracts, writing python code and deploy to Vault Core
    - **Managing accounts**, every time a customer opens a new account, a Smart Contract is executed to determine the parameters and operations of this account
    - **Postings**: either via Postings API or the Smart Contracts can generate events themselves. The Ledger records these events
    - **Managing customers**: *Vault Core cannot handle PII* so these information has to be stored some where else. The holding of a customer in Vault Core is linked to this information via a *unique ID*.

- Other functionalities within a bank:
    - **KYC and AML**: verify identities and avoid risky customers
    - **Cards and payments**: make and receive payments from other banks
    - **Fraud monitoring**
    - **Credit scoring and credit risks**: who to lend to and how much
    - **Data reporting and analysis**

# Vault Core Architecture
## Vault Core APIs
- There are 4 entities that Vault Core is responsible for:
    - Product: these are smart contract written in Python and can be deployed to Vault. Vault will run these contracts and other microservices will carry out the relevants tasks dictated by the Python code.
    - Account: there are 2 types of account: Internal and Customer account. The Customer account is an instance of a smart contract so when a customer opens an account, a version of a smart contract is run. Each customer account has balances.
    - Postings: these are events generated and kept track by the Vault Core when there are movements of funds. There are 2 sources of postings: Postings API and Contract API. Postings API will be used in the lifecycle of funds transfer. Contract API is used when needed, for example when the interest or fee accumulates. The ledger persists any events generated by both sources.
    - Customer: unique ID to link with external Customer Relationship Management (CRM)

## Thought Machine Application Architecture
- There are 2 layers of TM application:
    - Configuration Layer: customizable, TM provides tools and training, specific for each client
    - Platform Layer: common for all clients
- The Configuration Layer is totally customizable for the end user. It comprises of Chart of Accounts and Smart Contracts.
- The client can build their own applications based on their needs, using the tooling and training from TM.
- The Platform Layer is built by TM and the client can only use the APIs to upload the content of Configuration Layer like Smart Contracts so that the Vault can run them.
- Vault Core can be run with only the changes from Configuration Layer (Smart Contracts)
- Each smart contract can be scheduled to run certain functions instead of relying on a global schedule.
- Instead of having multiple APIs/components for types of payments, Vault Core has only 1 postings/payments API that any payments can hook on the same way.
- Payment devices like credit cards are not depenedent on the account logic so 1 device and be hooked onto multiple accounts. For example a payment card can be associated with a debit account and a credit account account and the customer can switch between them.
- Cloud native, highly available, can run in multiple regions, can use CSP's backup solution instead of manual backup.

## Creative Migration Strategies
- Vault Core offers solution to migrate existing data into the new system with 6 key properties
    - Data is migrated and maintained and **account level**, via APIs that support real-time sync
    - Dependency management, can config dependencies so that we can input data in any order but it's only loaded until all dependencies are met.
    - Load process is fully automated from API request to streamed events
    - Real-time event streaming which can immediately provide data to downstream systems.
    - When testing, can fast forward in time to test how the legacy products behaves against the known baseline.
    - Strategies like Production parallel run and other migration designs based on the event streaming architecture

## APIs
- Internally, Vault Core has a microservice architecture including these smaller services:
    - **Products and Accounts**: manages smart contracts, customer accounts (also smart contracts), chart of accounts and double-entry bookkeeping (debit and credit recording)
    - **Flags and Parameters**: manages all parameters configured for the smart contracts
    - **Postings and Balances**: keep tracking of fund movements, the ledger prioritizes from high to low topics. Point in time processor handles postings from scheduled events. Balances are side effects of postings.
    - **Calendar and schedule**: manages the scheduled events defined by smart contracts.

- Core API: 
    - Account management: view accounts, open/close accounts, change status, update instance parameters of an account
    - Product management: upload or change version of smart contracts
    - Restriction: restrict accounts in case of lost card or malicious activities, stop accounts from being closed or updated.
    - Smart contract simulation
    - Internal accounts: chart of accounts
    - Roles management: manage employee roles and service tokens 
    - Flags: add flags to accounts or customer entities, allows to impact the accounts for custom reasons.
- Postings API:
    - Authorization check on accounts
    - Settlement of funds
    - Release of funds
    - Posting debits and credits to Vault.
- Streaming API:
    - Account change events
    - Accounting events
    - Posting balances events
    - Customer entity status changes
    - Payment device events
    - Smart contract activation, version change
    - Configuration change.
- Data Loader API: load data from legacy core to Vault Core. Data is loaded asynchronously via Kafka. All data is loaded throught 1 API, except for postings. It's basically an ETL pipeline. By the time the data is loaded to Vault Core, it's already extracted and transformed into an appropriate format.
- The Postings APIs are integrated into Vault Payment processor and Vault Card processor. This is done out side of Vault Core so it's not responsible. All payment schemes and cards are integrated in the same manner.
- Outside the payment processor and card processor, we also have our own payment/card scheme and fraud engine
- The streaming API allows stream events to other systems like Data Warehouse. It's recommended to consume all events to get a complete picture.

## Middle Tier system
- Outside of Vault Core, can use a middle tier system to integrate with the wider banking systems like notification, authentication 

## Operation Dashboard
- Allows back office users to carry out tasks using GUI, integrated with Core API.
- Has role based access control
- Each action has a permission
- Sets of permissions are grouped in to roles, each employee is assigned role.
- It has tools to service products and accounts held in Platform Layer.
- It can upload new or updated version of smart contracts.

## Configuration data in Vault
- There are 3 ways to deploy smart contracts to Vault Core
    - Operation dashboard
    - Core API
    - Configuraiton layer utilities
- Operation dashboard and Core API are mostly used to upload POC smart contracts
- Most banks want to deploy new contracts via CICD pipelines using the Configuration layer utilities.
- There are 4 types of data in Vault Core:
    - **Financial data**: ledger, accounts data store, balances data store, this the the source of truth
    - **Configuration data**: smart contracts, Configuration Layer Utilities is used to deploy smart contracts
    - **Supplementary data**: data used by Vault Apps (Configuration layer???)
    - **Service data**: data used to monitor the Vault instances, including logs and tracing.
## Entity model
- There are 3 types of entities in Vault Core
    - Postings ledger: contains all fund movements
    - Balance data store: balances are the aggregation of postings
    - Account data store: each account is an object associated with resources that make up a bank account, including stakeholders, balances. Each account is an instance of a smart contract.
- Postings are appended to the ledger and cannot be changed, the list of postings is the source of truth and is used to calculate the balances
- There are 2 types of accounts: Internal and Customer account.
- Internal accounts are not defined by Smart contracts and is used to allocate and track funds for the financial institution.
- Each customer account can be divided into multiple addresses, each address has its balance. The balance of each address is calculated by the postings made against that address.
- The structure of addresses is dictated by the smart contract but can also be dynamically creatd when a posting is accepted (maybe a posting that doesn't belong to any existing addresses???)
- The net balance of an address is calculated according to the type of the account: asset or liability.

# Key Resources and Data Model
## Vault Architecture Principles
- All objects in Vault core can be created, read, updated and deleted via Core API
- Objects are only soft deleted
- Objects are only appending updated, meaning a new version of an object is created.

## Vault's data dictionary
- Vault documentation hub provides the documents, tutorial for all the changes of Vault Core.
- There are also Migration Data Dictionary, Migration Tech Deck and Migration Client Case Studies.
- Data Dictionary provides describes the validation requirements for all API fields when a request is sent to Data Loader API or Postings Migration API. It describes how Vault treat migrated resources.

## Key Account Resources
- Beside Core, Postings and Streaming API, Vault Core also has the following APIs:
    - Audit API: audit all incoming API requests
    - Data Loader API: migrate legacy systems' data.
    - Access Control API: manage roles of employees.

## Smart Contract entities
- Smart contracts are the entities that digitally enforce the agreements between the bank and customers, therefore they define the finacial behaviors of an account and how the balances are calculated.
- All products are smart contracts and they are the finacial behaviors of an account.
- Each product has some metadata and a product version number which points to the version.
- This product version point the Customer Account to the version of the Smart Contract it executes
- Each product has multiple versions, each version can be linked to multiple customer accounts
- Each product version contains the code of Smart Contract such as Metadata, parameters, events, data fetchers and hooks
- All live customer accounts point to a product version in Vault Core.
- A product can be upgraded to the latest version of the smart contract.

## Account Data Model
- Thought Machine doesn't have CRM and only provides an external ID field to connect with external CRM systems.
- Vault Core provides some fields like first name and last name if necessary.
- A customer can be linked to multiple accounts, an account can also have multiple customers linked via the field stakeholders.
- An account contains the monetary data and metadata includes:
    - Opening date
    - Stakeholders
    - Instance parameters
    - Linked payment devices
    - Account details, follows key-value structure to capture custom data.
- Update accounts via Account Update API
- Not all updates to accounts can be done synchronously, because some of them require smart contract code to be run. These updates include
    - Change instance parameters because it requires *pre_parameter_change_code* to be run
    - Change product version because it requires *upgrade_code* to be run
- All customer accounts have at least 1 balance.
- Balances are calculated using 4 dimensions
    - **Asset type** (Commercial bank money or another asset type)
    - **Denomination** (currencies like USD, SGD)
    - **Address**, address maybe where to track interest or to store sub-pots for saving or where the bank can track fees 
    - **Phase**, there are 3 phases *Incoming*, *Outgoing* and *Committed*
- Balances have 3 attributes:
    - Total debit
    - Total credit
    - Net: depending on the type (T-side) of the account Asset or Liability

## Payment devices
- Payment devices provides external account ID
- Customers can select account to charge using a single card, customer can route the payment to multiple accounts and can 1 account can have unlimited number of supplementary cards
- A payment device can be email, card, account number, phone number, physical payment device ...
- A payment device can link to 1 or multiple accounts using unique Payment Device Links
- Each link has a token that can be used to identify the links and make postings to.
- Multiple devices linking to the same account can share 1 token with each device having status Active or Inactive.
- Or each link can have a unique token created by external systems to enable

## Posting Instruction batches
- Posting Instruction batches represent the movements of funds between accounts.
- A single Posting Instrcution batch is made up of many Posting instruction.
- A Posting instruction always contains at least 2 postings, credit and debit.
- Higher level concepts like transactions and payments are just made up of postings, for example transactions are made up of 2 or more postings
- If we need to reverse or correct a posting, we have to make new backdated postings

## Internal accounts
- Internal accounts are internal accounts of the bank, it shows how much money the bank owns
- It's used on the Vault ledger to meet accounting requirements
- Internal accounts don't use smart contracts liks Customer accounts with any metadata, it only uses a blank Smart contract to maximize performance.
- Internal accounts are not associated with a customer entity, they're owned by the bank itself

## Audit entities
- Audit module tracks requests and effects of those requests on the resources in Vault Core.
- The audit events can be accessed via REST API or Kafka (Audit Streaming API)
- Audit logs record all incoming requests and responses
- Action logs record the action that these requests perform on the entities in Vault Core such as accounts or payments and the information changed by these actions.
- Both log types are immutable and can be acccessed via REST API or Audit Streaming API, they can also be viewed from Operation Dashboard.
- Audit logs are kept for some time while Action logs are kept indefinitely.
- While Audit logs remove sensitive information like tokens, it won't remove things like balances, postings or account data.
- We need to use policies to limit the number of users who can view the Audit logs.

